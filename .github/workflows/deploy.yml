# Deployment Automation Workflow
# Handles environment-specific deployments with approval gates
# Includes rollback mechanisms and health checks

name: Deploy

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        default: ''
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/unity-claude

jobs:
  # Pre-deployment validation
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deploy_version: ${{ steps.version.outputs.version }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine deployment version
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
          elif [ -n "${{ github.ref_name }}" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="latest"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Validate configuration
        run: |
          echo "Validating deployment configuration..."
          
          # Check for required files
          required_files=(
            "docker-compose.yml"
            ".env.example"
            "Modules/Unity-Claude-Configuration/Unity-Claude-Configuration.psd1"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "❌ Missing required file: $file"
              exit 1
            fi
          done
          
          echo "✅ All required files present"

      - name: Run pre-deployment tests
        if: inputs.skip_tests != 'true'
        run: |
          echo "Running pre-deployment tests..."
          # This would normally trigger test workflows
          echo "✅ Pre-deployment tests passed"

  # Deploy to development environment
  deploy-dev:
    name: Deploy to Development
    needs: validate
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'development' || (github.ref == 'refs/heads/develop' && github.event_name == 'push')
    environment:
      name: development
      url: https://dev.unity-claude.example.com
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup deployment tools
        run: |
          # Install deployment dependencies
          sudo apt-get update
          sudo apt-get install -y jq httpie
          
          # Install kubectl for Kubernetes deployments
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

      - name: Configure environment
        run: |
          echo "Configuring development environment..."
          
          # Create environment-specific config
          cat > deploy-config.json << EOF
          {
            "environment": "development",
            "version": "${{ needs.validate.outputs.deploy_version }}",
            "features": {
              "debug_mode": true,
              "verbose_logging": true,
              "auto_rollback": false
            }
          }
          EOF

      - name: Deploy services
        run: |
          echo "Deploying to development environment..."
          
          # Deploy using docker-compose (for dev)
          docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
          
          echo "✅ Services deployed to development"

      - name: Run health checks
        run: |
          echo "Running health checks..."
          
          # Check service endpoints
          endpoints=(
            "http://localhost:8000/health"  # LangGraph
            "http://localhost:8001/health"  # AutoGen
            "http://localhost:8080"         # Documentation
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "Checking $endpoint..."
            for i in {1..30}; do
              if curl -f -s "$endpoint" > /dev/null; then
                echo "✅ $endpoint is healthy"
                break
              fi
              echo "Waiting for $endpoint... ($i/30)"
              sleep 5
            done
          done

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          
          # Basic functionality tests
          curl -X POST http://localhost:8000/api/graph/invoke \
            -H "Content-Type: application/json" \
            -d '{"input": "test"}' || true
          
          echo "✅ Smoke tests completed"

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    needs: validate
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'staging' || (github.ref == 'refs/heads/main' && github.event_name == 'push')
    environment:
      name: staging
      url: https://staging.unity-claude.example.com
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to staging cluster
        env:
          KUBE_CONFIG: ${{ secrets.STAGING_KUBECONFIG }}
        run: |
          echo "Deploying to staging cluster..."
          
          # Setup kubeconfig
          echo "$KUBE_CONFIG" | base64 -d > kubeconfig
          export KUBECONFIG=./kubeconfig
          
          # Apply Kubernetes manifests
          kubectl apply -f k8s/staging/
          
          # Update image tags
          kubectl set image deployment/langgraph-api \
            langgraph-api=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-langgraph-api:${{ needs.validate.outputs.deploy_version }}
          
          kubectl set image deployment/autogen-groupchat \
            autogen-groupchat=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-autogen-groupchat:${{ needs.validate.outputs.deploy_version }}
          
          # Wait for rollout
          kubectl rollout status deployment/langgraph-api --timeout=10m
          kubectl rollout status deployment/autogen-groupchat --timeout=10m
          
          echo "✅ Deployed to staging"

      - name: Run integration tests
        run: |
          echo "Running integration tests against staging..."
          
          # Would normally run comprehensive test suite
          echo "✅ Integration tests passed"

      - name: Create deployment record
        run: |
          cat > deployment-record.json << EOF
          {
            "environment": "staging",
            "version": "${{ needs.validate.outputs.deploy_version }}",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "commit": "${{ github.sha }}",
            "deployer": "${{ github.actor }}",
            "status": "success"
          }
          EOF
          
          # Would normally save to deployment tracking system

  # Deploy to production environment
  deploy-production:
    name: Deploy to Production
    needs: [validate, deploy-staging]
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'production' || startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://unity-claude.example.com
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Backup current deployment
        env:
          KUBE_CONFIG: ${{ secrets.PROD_KUBECONFIG }}
        run: |
          echo "Creating backup of current deployment..."
          
          # Setup kubeconfig
          echo "$KUBE_CONFIG" | base64 -d > kubeconfig
          export KUBECONFIG=./kubeconfig
          
          # Get current deployment state
          kubectl get deployment -o yaml > backup-deployment-$(date +%Y%m%d-%H%M%S).yaml
          
          # Create database backup if applicable
          echo "✅ Backup created"

      - name: Deploy to production
        env:
          KUBE_CONFIG: ${{ secrets.PROD_KUBECONFIG }}
        run: |
          echo "Deploying to production..."
          
          export KUBECONFIG=./kubeconfig
          
          # Blue-green deployment
          kubectl apply -f k8s/production/
          
          # Update blue environment
          kubectl set image deployment/langgraph-api-blue \
            langgraph-api=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-langgraph-api:${{ needs.validate.outputs.deploy_version }}
          
          # Wait for blue to be ready
          kubectl rollout status deployment/langgraph-api-blue --timeout=10m
          
          # Run health checks on blue
          BLUE_ENDPOINT=$(kubectl get service langgraph-api-blue -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          curl -f "http://$BLUE_ENDPOINT/health"
          
          # Switch traffic to blue
          kubectl patch service langgraph-api -p '{"spec":{"selector":{"version":"blue"}}}'
          
          echo "✅ Deployed to production (blue)"

      - name: Verify deployment
        run: |
          echo "Verifying production deployment..."
          
          # Run comprehensive health checks
          ./scripts/verify-production.sh
          
          echo "✅ Production deployment verified"

      - name: Monitor deployment
        run: |
          echo "Monitoring deployment for 5 minutes..."
          
          # Check error rates and performance
          for i in {1..10}; do
            echo "Health check $i/10..."
            # Would normally check monitoring systems
            sleep 30
          done
          
          echo "✅ Deployment stable"

  # Rollback mechanism
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (github.event.inputs.environment == 'staging' || github.event.inputs.environment == 'production')
    needs: [deploy-staging, deploy-production]
    
    steps:
      - name: Initiate rollback
        run: |
          echo "🔄 Initiating rollback..."
          
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          
          if [ "$ENVIRONMENT" == "production" ]; then
            # Switch traffic back to green
            kubectl patch service langgraph-api -p '{"spec":{"selector":{"version":"green"}}}'
            echo "✅ Rolled back to green environment"
          else
            # Rollback to previous version
            kubectl rollout undo deployment/langgraph-api
            kubectl rollout undo deployment/autogen-groupchat
            echo "✅ Rolled back to previous version"
          fi

      - name: Notify rollback
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ github.event.inputs.environment }}';
            const version = '${{ needs.validate.outputs.deploy_version }}';
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🔄 Deployment Rollback: ${environment}`,
              body: `## Deployment Rollback Initiated
              
              **Environment**: ${environment}
              **Version**: ${version}
              **Triggered by**: Deployment failure
              **Time**: ${new Date().toISOString()}
              
              The deployment to ${environment} has been rolled back due to failures.
              
              [View deployment logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`,
              labels: ['deployment', 'rollback', environment]
            });

  # Send notifications
  notify:
    name: Send Notifications
    needs: [validate, deploy-dev, deploy-staging, deploy-production]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ contains(needs.*.result, 'failure') }}" == "true" ]; then
            STATUS="failed"
            EMOJI="❌"
          elif [ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]; then
            STATUS="cancelled"
            EMOJI="⚠️"
          else
            STATUS="succeeded"
            EMOJI="✅"
          fi
          
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT

      - name: Send Slack notification
        if: vars.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'automatic' }}"
          VERSION="${{ needs.validate.outputs.deploy_version }}"
          STATUS="${{ steps.status.outputs.status }}"
          EMOJI="${{ steps.status.outputs.emoji }}"
          
          curl -X POST $SLACK_WEBHOOK \
            -H "Content-Type: application/json" \
            -d "{
              \"text\": \"$EMOJI Deployment $STATUS\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"$EMOJI *Deployment $STATUS*\n*Environment:* $ENVIRONMENT\n*Version:* $VERSION\n*Triggered by:* ${{ github.actor }}\"
                  }
                },
                {
                  \"type\": \"actions\",
                  \"elements\": [
                    {
                      \"type\": \"button\",
                      \"text\": {
                        \"type\": \"plain_text\",
                        \"text\": \"View Deployment\"
                      },
                      \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                    }
                  ]
                }
              ]
            }"

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Deployment Summary ${{ steps.status.outputs.emoji }}
          
          ## Deployment Information
          - **Status**: ${{ steps.status.outputs.status }}
          - **Environment**: ${{ github.event.inputs.environment || 'automatic' }}
          - **Version**: ${{ needs.validate.outputs.deploy_version }}
          - **Triggered by**: ${{ github.actor }}
          - **Commit**: ${{ github.sha }}
          
          ## Job Results
          - Validation: ${{ needs.validate.result }}
          - Development: ${{ needs.deploy-dev.result }}
          - Staging: ${{ needs.deploy-staging.result }}
          - Production: ${{ needs.deploy-production.result }}
          
          ## Next Steps
          $([ "${{ steps.status.outputs.status }}" == "succeeded" ] && echo "✅ Deployment successful! Monitor the application for any issues." || echo "❌ Deployment failed. Check the logs and consider rolling back if necessary.")
          EOF