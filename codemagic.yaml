workflows:
  ios-tca-dashboard:
    name: iOS TCA Dashboard
    max_build_duration: 60
    instance_type: mac_mini_m2

    environment:
      xcode: 16.2
      cocoapods: default
      vars:
        PROJECT_PATH: "iOS-App/AgentDashboard/AgentDashboard.xcodeproj"
        SCHEME: "AgentDashboard"

    scripts:
      - name: Verify repository and code
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          echo "=== Repository info ==="
          echo "PWD: $(pwd)"
          echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Current commit: $(git rev-parse --short HEAD)"
          echo "Remote URL: $(git remote get-url origin)"
          
          echo "=== Verify iOS-App exists ==="
          if [ -d "iOS-App/AgentDashboard" ]; then
            echo "✅ iOS-App/AgentDashboard directory found"
            ls -la iOS-App/AgentDashboard/ | head -5
          else
            echo "❌ ERROR: iOS-App/AgentDashboard directory not found!"
            exit 1
          fi
          
          echo "=== Verify APIClient has required methods ==="
          F="iOS-App/AgentDashboard/AgentDashboard/Network/APIClient.swift"
          if [ -f "$F" ]; then
            echo "✅ APIClient.swift found"
            echo "Checking for required methods:"
            grep -E "func fetchAgents\(" "$F" && echo "✅ fetchAgents found" || echo "❌ fetchAgents missing"
            grep -E "func startAgent\(" "$F" && echo "✅ startAgent found" || echo "❌ startAgent missing"
            grep -E "func stopAgent\(" "$F" && echo "✅ stopAgent found" || echo "❌ stopAgent missing"
          else
            echo "❌ ERROR: APIClient.swift not found at $F"
            exit 1
          fi
          
      - name: Toolchain info
        script: |
          #!/usr/bin/env bash
          set -e
          xcodebuild -version
          swift --version
          xcrun simctl list runtimes

      - name: Clean DerivedData & resolve packages (with logs)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          echo "=== Cleaning DerivedData and SPM caches completely ==="
          rm -rf "$CM_BUILD_DIR/DerivedData" || true
          rm -rf "$HOME/Library/Developer/Xcode/DerivedData" 2>/dev/null || true
          rm -rf "$HOME/Library/Developer/Xcode/DerivedData/SourcePackages" 2>/dev/null || true
          rm -rf "$CM_BUILD_DIR/DerivedData/SourcePackages" 2>/dev/null || true
          rm -rf "$CM_BUILD_DIR/SourcePackages" 2>/dev/null || true
          
          # Clean SPM cache to prevent stale plugin builds
          rm -rf ~/Library/Caches/org.swift.swiftpm 2>/dev/null || true
          rm -rf ~/Library/Developer/Xcode/DerivedData/ModuleCache.noindex 2>/dev/null || true
          
          # CRITICAL: Clear the global SPM cache to force re-download
          rm -rf ~/Library/Developer/Xcode/DerivedData/AgentDashboard-*/SourcePackages 2>/dev/null || true
          rm -rf ~/Library/Caches/org.swift.swiftpm/repositories 2>/dev/null || true
          
          echo "=== xcodebuild toolchain ==="
          xcodebuild -version
          swift --version || true
          
          # Enable diagnostic output for macro issues
          export SWIFT_LOADED_PLUGINS_DUMP=1
          export SWIFT_MACRO_EXPAND_DIAGS=1
          
          echo "=== Resolve Swift packages (fresh) ==="
          defaults write com.apple.dt.Xcode IDEPackageEnablePrebuilts YES || true
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -derivedDataPath "$CM_BUILD_DIR/DerivedData" \
            -clonedSourcePackagesDirPath "$CM_BUILD_DIR/SourcePackages" \
            -skipPackagePluginValidation \
            -skipMacroValidation \
            -verbose || true
          
          echo "=== Show build settings (captures SPM locations) ==="
          xcodebuild -showBuildSettings \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" | tee "$CM_BUILD_DIR/build-settings.txt"
          
          echo "=== Find Package.resolved files ==="
          find iOS-App -name Package.resolved -print -exec cat {} \; || true
          
          echo "=== Capture Package.resolved ==="
          RESOLVED_SRC="$CM_BUILD_DIR/DerivedData/SourcePackages/Package.resolved"
          RESOLVED_OUT="$CM_BUILD_DIR/Artifacts/Package.resolved"
          mkdir -p "$CM_BUILD_DIR/Artifacts"
          if [ -f "$RESOLVED_SRC" ]; then
            cp "$RESOLVED_SRC" "$RESOLVED_OUT"
            echo "Saved Package.resolved to artifacts"
          else
            echo "No Package.resolved at $RESOLVED_SRC"
          fi

      - name: Select iOS 18.x simulator, set SIM_UDID for xcodebuild
        script: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Help TCA macro host compile
          export MACOSX_DEPLOYMENT_TARGET=14.0

          echo "=== Selecting iOS 18.x simulator ==="
          # Use self-contained external script
          SIM_UDID="$(python3 ci/select_simulator.py "18.2" "iPhone 16 Pro")"
          if [[ -z "${SIM_UDID:-}" ]]; then
            echo "ERROR: Could not find an iOS 18.x simulator UDID" >&2
            echo "== Devices =="; xcrun simctl list devices
            exit 1
          fi

          echo "Selected simulator UDID: $SIM_UDID"
          echo "export SIM_UDID=$SIM_UDID" >> "$CM_ENV"

      - name: Debug - list all @main App matches
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          echo "=== Finding all @main declarations ==="
          if command -v rg &> /dev/null; then
            echo "Using ripgrep:"
            rg -n -g 'iOS-App/**/*.swift' '@main' || echo "No matches found"
          else
            echo "Using grep:"
            grep -r -n "@main" iOS-App --include="*.swift" || echo "No matches found"
          fi
          echo ""
          echo "=== Checking which files are in Xcode project ==="
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          echo "AgentDashboardApp.swift in project: $(grep -c "AgentDashboardApp.swift" "$PROJ" || echo 0)"

      - name: Sanity - ensure single @main App (project files only)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          echo "=== Checking for @main App in project files ==="
          
          # Simple approach: just check if AgentDashboardApp.swift exists and has @main
          mainfile="iOS-App/AgentDashboard/AgentDashboard/AgentDashboardApp.swift"
          
          if [[ -f "$mainfile" ]]; then
            if grep -q "@main" "$mainfile"; then
              echo "✅ Found @main in AgentDashboardApp.swift"
            else
              echo "❌ AgentDashboardApp.swift missing @main"
              exit 1
            fi
          else
            echo "❌ AgentDashboardApp.swift not found"
            exit 1
          fi
          
          # Check for any other @main declarations
          otherMains=$(find iOS-App -name "*.swift" -not -name "AgentDashboardApp.swift" -exec grep -l "@main" {} \; | wc -l)
          
          if [ "$otherMains" -gt 0 ]; then
            echo "❌ Found @main in other files:"
            find iOS-App -name "*.swift" -not -name "AgentDashboardApp.swift" -exec grep -l "@main" {} \;
            exit 1
          fi
          
          echo "✅ Single @main App verified"

      - name: Sanity - verify key files are in Xcode project
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          echo "=== Checking target membership ==="
          
          # Critical files that MUST be in project
          critical=( ContentView.swift DashboardView.swift )
          for f in "${critical[@]}"; do
            if ! grep -q "$f" "$PROJ"; then
              echo "❌ CRITICAL: Not in project: $f"
              exit 1
            else
              echo "✅ Found: $f"
            fi
          done
          
          # Optional files (okay if missing due to temp wrappers)
          optional=( AgentsView.swift TerminalView.swift AnalyticsView.swift SettingsView.swift )
          for f in "${optional[@]}"; do
            if ! grep -q "$f" "$PROJ"; then
              echo "⚠️  Not in project: $f (using temp wrapper)"
            else
              echo "✅ Found: $f"
            fi
          done

      - name: Project integrity check
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PBX="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"

          echo "=== Sanity check pbxproj ==="
          head -n 10 "$PBX" || true
          echo

          # Check if it's a valid plist
          if ! plutil -lint "$PBX" 2>/dev/null; then
            echo "❌ project.pbxproj is not a valid plist. Restore it before building."
            exit 74
          fi

          echo "=== List targets (quick parse) ==="
          xcodebuild -list -project iOS-App/AgentDashboard/AgentDashboard.xcodeproj || true
          
          echo "✅ Project file is valid"

      - name: Verify no macro products linked
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          echo "=== Check that macro products are NOT linked in project ==="
          PBX="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          if grep -qE 'ComposableArchitectureMacros|CasePathsMacros|PerceptionMacros|DependenciesMacros' "$PBX"; then
            echo "❌ ERROR: Macro products are referenced in the pbxproj!"
            echo "Macro products should NOT be linked in Link Binary With Libraries or Target Dependencies."
            echo "Remove these references from the Xcode project:"
            grep -nE 'ComposableArchitectureMacros|CasePathsMacros|PerceptionMacros|DependenciesMacros' "$PBX" | head -10
            exit 1
          else
            echo "✅ No macro products linked in pbxproj - this is correct!"
            echo "Xcode will automatically handle macro building for the host platform."
          fi

      - name: Clean and resolve packages
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          echo "=== Clean everything for fresh build ==="
          rm -rf "$CM_BUILD_DIR/DerivedData"
          rm -rf ~/Library/Caches/org.swift.swiftpm
          rm -rf ~/Library/org.swift.swiftpm
          
          # Trust macros by default for CI
          defaults write com.apple.dt.Xcode IDESkipMacroFingerprintValidation -bool YES
          defaults write com.apple.dt.Xcode IDESkipPackagePluginFingerprintValidatation -bool YES
          
          echo "=== Force package update to get compatible versions ==="
          cd iOS-App/AgentDashboard
          
          # Remove any cached package state to force fresh resolution
          rm -rf ~/Library/Developer/Xcode/DerivedData/AgentDashboard-*/SourcePackages
          rm -rf AgentDashboard.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
          
          echo "=== Resolve packages fresh (this will get Xcode 16.2 compatible versions) ==="
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -derivedDataPath "$CM_BUILD_DIR/DerivedData" \
            -skipPackagePluginValidation \
            -skipMacroValidation \
            -clonedSourcePackagesDirPath "$CM_BUILD_DIR/SourcePackages"
          
          echo "=== Packages resolved with updated versions ==="
          
          echo "=== Verify we got Xcode 16.2 compatible packages ==="
          # Check the build log for resolved versions
          if [ -f "$CM_BUILD_DIR/build.log" ]; then
            RESOLVED_SYNTAX=$(grep -o "swift-syntax.*@ [0-9.]*" "$CM_BUILD_DIR/build.log" || echo "not found in build.log")
            echo "Resolved swift-syntax: $RESOLVED_SYNTAX"
            
            if echo "$RESOLVED_SYNTAX" | grep -q "601\."; then
              echo "❌ ERROR: Xcode 16.2 needs swift-syntax 600.x, but got 601.x"
              echo "The TCA version is too new. Need to downgrade further."
              # Don't exit yet, let's see if it works anyway
            elif echo "$RESOLVED_SYNTAX" | grep -q "600\."; then
              echo "✅ Got swift-syntax 600.x - compatible with Xcode 16.2!"
            fi
          fi

      - name: Sanity - print APIClient.swift head & checksum
        script: |
          #!/usr/bin/env bash
          set -e
          F="iOS-App/AgentDashboard/AgentDashboard/Network/APIClient.swift"
          echo "=== APIClient.swift HEAD (first 120 lines) ==="
          sed -n '1,120p' "$F" || true
          echo ""
          echo "=== APIClient.swift sha256 ==="
          shasum -a 256 "$F" || true
          echo ""
          echo "=== APIClient.swift helper methods check ==="
          grep -nE 'func (fetchAgents|startAgent|stopAgent|pauseAgent|resumeAgent|request)\(' "$F" || true

      - name: Debug - commit & branch
        script: |
          #!/usr/bin/env bash
          echo "=== Git info ==="
          echo "CM_BRANCH=${CM_BRANCH:-unset}"
          echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Last 5 commits:"
          git log --oneline -5

      - name: Build for iOS Simulator (arm64, single device, with result bundle)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV" || true

          DERIVED="$CM_BUILD_DIR/DerivedData"
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/build.log"

          # Macro plugins run on the macOS host; set a modern host target
          export MACOSX_DEPLOYMENT_TARGET=14.0
          
          # Enable diagnostic output for macro issues
          export SWIFT_LOADED_PLUGINS_DUMP=1
          export SWIFT_MACRO_EXPAND_DIAGS=1
          
          # Force clean module cache to prevent stale macro builds
          rm -rf "$DERIVED/ModuleCache.noindex"

          echo "=== Building Debug for simulator id=$SIM_UDID ==="
          
          # Capture build exit code but don't fail the step
          status=0
          xcodebuild \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -sdk iphonesimulator \
            -configuration Debug \
            -destination "platform=iOS Simulator,id=$SIM_UDID" \
            -derivedDataPath "$DERIVED" \
            -resultBundlePath "$BUNDLE" \
            -resultBundleVersion 3 \
            -skipMacroValidation \
            -skipPackagePluginValidation \
            ONLY_ACTIVE_ARCH=YES \
            EXCLUDED_ARCHS="i386 x86_64" \
            SWIFT_MACRO_PLUGIN_ENABLE=YES \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            -showBuildTimingSummary \
            build | tee "$LOG" || status=$?
          
          echo "$status" > "$CM_BUILD_DIR/build_status.txt"
          echo "Build exited with status: $status"
          
          echo "=== Where did the macro bundles land? ==="
          echo "Host (Debug) macros:"
          find "$DERIVED/Build/Products/Debug" -type f \( -name "*.dylib" -o -name "*.bundle" \) 2>/dev/null || echo "No host macros found"
          echo ""
          echo "Simulator (Debug-iphonesimulator) macros:"
          find "$DERIVED/Build/Products/Debug-iphonesimulator" -type d -name "*Macros*" 2>/dev/null || echo "No simulator macros found"
          echo ""
          echo "All macro-related files:"
          find "$DERIVED/Build/Products" -maxdepth 3 -name "*Macros*" -print || true
          
          # Always succeed this step so diagnostics can run
          exit 0

      # ---------- Diagnostics: richer error reporting -----------
      - name: Extract build errors comprehensively
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/build.log"
          
          echo "=== Swift diagnostics from xcresult (files + summaries) ==="
          if [ -d "$BUNDLE" ] && command -v jq >/dev/null 2>&1; then
            xcrun xcresulttool get --format json --path "$BUNDLE" \
            | jq -r '
                .. | objects? // empty
                | .[]?
                | select(.diagnosticType? or .issueType? or .type? or .title?)
                | [
                    (.documentLocationInCreatingWorkspace?.filePath? // .fileName? // ""),
                    ( .documentLocationInCreatingWorkspace?.startingLineNumber?
                      // .lineNumber?
                      // .startingLineNumber?
                      // "" ),
                    ( .message? // .summary? // .title? // .type? // "" )
                  ]
                | @tsv
              ' || true
          fi
          
          echo ""
          echo "=== Grep fallback (common swiftc format) ==="
          grep -nE '/AgentDashboard/.*\.swift:[0-9]+:[0-9]+: (error|warning):' "$LOG" || true
          
          echo ""
          echo "=== Any swift-frontend/swift-driver crashes? ==="
          grep -nE 'swift-(frontend|driver).* (error|crash|segmentation|fatal)' "$LOG" || true
          
          echo ""
          echo "=== PBXProj has correct source entries? ==="
          PBX=iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj
          grep -n 'APIClient.swift' "$PBX" && echo "✅ APIClient.swift in pbxproj" || echo "❌ APIClient.swift not in pbxproj"
          grep -n 'AgentsFeature.swift' "$PBX" && echo "✅ AgentsFeature.swift in pbxproj" || echo "❌ AgentsFeature.swift not in pbxproj"
          
          echo ""
          echo "=== Unique files on disk ==="
          find iOS-App -name 'APIClient.swift' -o -name 'AgentsFeature.swift' -print
      
      - name: Extract ALL Swift diagnostics (file + line) v2
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/build.log"

          if [[ ! -d "$BUNDLE" ]]; then
            echo "No xcresult bundle at: $BUNDLE"
            exit 0
          fi

          # First try the diagnostics command which gives the best output
          echo "=== Extracting diagnostics from xcresult ==="
          xcrun xcresulttool diagnostics --path "$BUNDLE" 2>&1 || true
          
          echo ""
          echo "=== Extracting formatted results ==="
          xcrun xcresulttool formatDescription --path "$BUNDLE" 2>&1 || true
          
          # Get JSON output for detailed parsing
          xcrun xcresulttool get --format json --path "$BUNDLE" > "$CM_BUILD_DIR/xc.json" || {
            echo "xcresulttool failed; printing basic info and falling back to raw log."
            ls -al "$BUNDLE" || true
          }

          echo "=== A) Issues from actionResult.issues.errorSummaries / warningSummaries ==="
          PY_A="$CM_BUILD_DIR/py_extract_a.py"
          printf '%s\n' \
            'import json, os, sys' \
            'p = os.path.join(os.environ.get("CM_BUILD_DIR","."), "xc.json")' \
            'try:' \
            '    with open(p, "r", encoding="utf-8") as f:' \
            '        root = json.load(f)' \
            'except Exception as e:' \
            '    print(f"(could not open {p}: {e})"); sys.exit(0)' \
            '' \
            'out=[]' \
            'def walk(node):' \
            '    if isinstance(node, dict):' \
            '        if node.get("_type", {}).get("_name") == "ActionRecord":' \
            '            issues = node.get("issues", {})' \
            '            for key in ("errorSummaries","warningSummaries"): ' \
            '                v = issues.get(key, {})' \
            '                vals = v.get("_values", []) if isinstance(v, dict) else []' \
            '                for it in vals:' \
            '                    msg = (it.get("message") or {}).get("text","")' \
            '                    loc = it.get("documentLocationInCreatingWorkspace") or {}' \
            '                    url = loc.get("url",""); line = loc.get("line")' \
            '                    out.append((key, msg, url, line))' \
            '        for val in node.values(): walk(val)' \
            '    elif isinstance(node, list):' \
            '        for val in node: walk(val)' \
            '' \
            'walk(root)' \
            'if out:' \
            '    print(f"Found {len(out)} summarized issues\n")' \
            '    for kind,msg,url,line in out[:50]:' \
            '        print(("✖" if kind=="errorSummaries" else "⚠"), msg)' \
            '        if url:  print("   file:", url)' \
            '        if line: print("   line:", line)' \
            '        print()' \
            'else:' \
            '    print("(no summarized issues in actionResult)")' \
            > "$PY_A"
          python3 "$PY_A"

          echo
          echo "=== B) Follow logRef(s) and print error lines ==="
          PY_B="$CM_BUILD_DIR/py_extract_b.py"
          printf '%s\n' \
            'import json, os, subprocess, sys' \
            'cm = os.environ.get("CM_BUILD_DIR",".")' \
            'bundle = os.path.join(cm, "build.xcresult")' \
            'xcjson = os.path.join(cm, "xc.json")' \
            'try:' \
            '    root = json.load(open(xcjson, "r", encoding="utf-8"))' \
            'except Exception as e:' \
            '    print(f"(no xc.json to parse: {e})"); sys.exit(0)' \
            '' \
            'ids=set()' \
            'def walk(n):' \
            '    if isinstance(n, dict):' \
            '        for k in ("logRef","consoleLogRef"):' \
            '            ref = n.get(k)' \
            '            if isinstance(ref, dict) and ref.get("_id"):' \
            '                ids.add(ref["_id"])' \
            '        for v in n.values(): walk(v)' \
            '    elif isinstance(n, list):' \
            '        for v in n: walk(v)' \
            'walk(root)' \
            '' \
            'def get_text(_id):' \
            '    try:' \
            '        out = subprocess.check_output([' \
            '            "xcrun","xcresulttool","get","--format","json","--path", bundle, "--id", _id' \
            '        ], text=True)' \
            '    except subprocess.CalledProcessError:' \
            '        return ""' \
            '    try:' \
            '        j = json.loads(out)' \
            '    except Exception:' \
            '        return out' \
            '    acc=[]' \
            '    def collect(n):' \
            '        if isinstance(n, dict):' \
            '            t = n.get("text")' \
            '            if isinstance(t, str): acc.append(t)' \
            '            for v in n.values(): collect(v)' \
            '        elif isinstance(n, list):' \
            '            for v in n: collect(v)' \
            '    collect(j)' \
            '    return "".join(acc)' \
            '' \
            'hit=False' \
            'for _id in ids:' \
            '    txt = get_text(_id)' \
            '    if not txt: continue' \
            '    lines = [l for l in txt.splitlines() if " error:" in l or l.strip().startswith("error:")]' \
            '    if lines:' \
            '        hit=True' \
            '        print(f"--- LOG ID {_id} (filtered) ---")' \
            '        print("\n".join(lines[:200]))' \
            '        print()' \
            'if not hit:' \
            '    print("(no error-like lines found in logRef text)")' \
            > "$PY_B"
          python3 "$PY_B"

          echo
          echo "=== C) Fallback: tail build log ==="
          if [[ -f "$LOG" ]]; then
            tail -n 500 "$LOG" | sed -n '/error:/,$p' | head -n 400 || true
          else
            echo "(no $LOG)"
          fi

          # Never fail this step so the final status gate can re-emit the build code
          exit 0


      - name: Show failing source context (best effort)
        script: |
          #!/usr/bin/env bash
          set +e
          python3 ci/show_source_context.py
          true
          
      - name: Detect dependency graph issues
        script: |
          #!/usr/bin/env bash
          set +e
          python3 ci/detect_dependency_errors.py "$CM_BUILD_DIR/build.log"
          true

      - name: Publish diagnostics & build settings
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          DERIVED="$CM_BUILD_DIR/DerivedData"
          mkdir -p "$CM_EXPORT_DIR"
          [[ -f "$CM_BUILD_DIR/build.log" ]] && cp "$CM_BUILD_DIR/build.log" "$CM_EXPORT_DIR/"
          [[ -f "$CM_BUILD_DIR/xc.json"   ]] && cp "$CM_BUILD_DIR/xc.json" "$CM_EXPORT_DIR/xcresult.json"
          [[ -d "$CM_BUILD_DIR/build.xcresult" ]] && cp -R "$CM_BUILD_DIR/build.xcresult" "$CM_EXPORT_DIR/"
          if [[ -d "$DERIVED" ]]; then
            (cd "$DERIVED" && zip -qry "$CM_EXPORT_DIR/deriveddata-logs.zip" Logs Build/Intermediates.noindex || true)
            xcodebuild -project "$PROJECT_PATH" -scheme "$SCHEME" -showBuildSettings > "$CM_EXPORT_DIR/build-settings.txt" || true
          fi
          echo "Artifacts:"
          ls -lah "$CM_EXPORT_DIR"

      - name: Fail pipeline if build failed
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          status=$(cat "$CM_BUILD_DIR/build_status.txt" 2>/dev/null || echo 0)
          if [[ "$status" -ne 0 ]]; then
            echo "❌ xcodebuild exited with status $status"
            exit "$status"
          fi
          echo "✅ Build succeeded"

      # ---------- Package a Preview artifact, only if the .app is real ----------
      - name: Validate and package app for Codemagic Preview (conditional)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          DERIVED="$CM_BUILD_DIR/DerivedData/Build/Products/Debug-iphonesimulator"
          APP_DIR="$(find "$DERIVED" -maxdepth 1 -type d -name '*.app' -print -quit || true)"

          if [[ -z "${APP_DIR:-}" ]]; then
            echo "❌ No .app produced (build failed). Skipping preview packaging."
            exit 0
          fi

          PLIST="$APP_DIR/Info.plist"
          if [[ ! -f "$PLIST" ]]; then
            echo "❌ $APP_DIR has no Info.plist — invalid app. Skipping."
            exit 0
          fi

          EXEC=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleExecutable' "$PLIST" 2>/dev/null || true)
          if [[ -z "${EXEC:-}" || ! -f "$APP_DIR/$EXEC" ]]; then
            echo "❌ Missing main executable — app wasn’t linked. Skipping."
            exit 0
          fi

          mkdir -p "$CM_EXPORT_DIR"
          ZIP="$CM_EXPORT_DIR/app-preview.zip"
          ( cd "$(dirname "$APP_DIR")" && /usr/bin/zip -qry "$ZIP" "$(basename "$APP_DIR")" )
          cp -R "$APP_DIR" "$CM_EXPORT_DIR/"

          echo "✅ Preview artifact: $ZIP"
          du -sh "$APP_DIR" || true
          ls -lah "$CM_EXPORT_DIR"

    artifacts:
      - $CM_ARTIFACTS/**
      - $CM_BUILD_DIR/Artifacts/Package.resolved