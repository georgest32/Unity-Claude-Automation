workflows:
  ios-tca-dashboard:
    name: iOS (TCA) — Build, extract errors, and prepare Preview
    max_build_duration: 60
    environment:
      xcode: 16.4
      vars:
        IOS_VERSION: "18.5"
        DEVICE_NAME: "iPhone 16 Pro"
        PROJECT_PATH: "iOS-App/AgentDashboard/AgentDashboard.xcodeproj"
        PRODUCT_SCHEME: "AgentDashboard"
      cocoapods: default
    cache:
      cache_paths:
        - $HOME/Library/Caches/org.carthage.CarthageKit
        - $HOME/Library/Developer/Xcode/DerivedData
        - $HOME/Library/Caches/pip
        - $HOME/Library/Caches/Homebrew
        - $HOME/Library/Developer/Xcode/Archives
        - $CM_BUILD_DIR/DerivedData
        - $CM_BUILD_DIR/Library/Caches
        - $HOME/Library/Developer/Xcode/SourcePackages

    scripts:
      - name: Print Xcode & Swift versions
        script: |
          set -euo pipefail
          xcodebuild -version
          swift --version
          xcrun simctl list runtimes
          xcrun simctl list devices

      - name: Select iOS 18.x simulator, set SIM_UDID for xcodebuild
        script: |
          #!/usr/bin/env bash
          set -euo pipefail

          WANT_OS="$IOS_VERSION"
          WANT_NAME="$DEVICE_NAME"

          echo "=== Finding $WANT_NAME with iOS $WANT_OS ==="

          # Prefer exact device name on the requested OS
          if SIM_UDID=$(xcrun simctl list devices "iOS $WANT_OS" | \
              awk -v n="$WANT_NAME" '
                $0 ~ n" " && $0 ~ /\(Shutdown\)|\(Booted\)/ {
                  if (match($0, /\(([A-F0-9-]{36})\)/, m)) { print m[1]; exit }
                }'); then
            :
          fi

          # Fallback to any iPhone 16 on that OS
          if [[ -z "${SIM_UDID:-}" ]]; then
            echo "$WANT_NAME ($WANT_OS) not found, using any iPhone 16 with $WANT_OS"
            SIM_UDID=$(xcrun simctl list devices "iOS $WANT_OS" | \
              awk '/iPhone 16/ && /\(Shutdown\)|\(Booted\)/ { if (match($0, /\(([A-F0-9-]{36})\)/, m)) { print m[1]; exit }}' || true)
          fi

          # Fallback to first device on that OS
          if [[ -z "${SIM_UDID:-}" ]]; then
            echo "No iPhone 16 found, using first available iOS $WANT_OS device"
            SIM_UDID=$(xcrun simctl list devices "iOS $WANT_OS" | \
              awk '/\(Shutdown\)|\(Booted\)/ { if (match($0, /\(([A-F0-9-]{36})\)/, m)) { print m[1]; exit }}' || true)
          fi

          if [[ -z "${SIM_UDID:-}" ]]; then
            echo "ERROR: No iOS $WANT_OS simulator found!"
            echo "== Devices =="
            xcrun simctl list devices
            exit 1
          fi

          echo "Selected simulator UDID: $SIM_UDID"
          echo "export SIM_UDID=$SIM_UDID" >> "$CM_ENV"

      - name: Build for iOS Simulator (arm64, single device, with result bundle)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV"

          # IMPORTANT: macros must build for macOS host, not the simulator
          unset SDKROOT
          export MACOSX_DEPLOYMENT_TARGET=13.0

          DERIVED="$CM_BUILD_DIR/DerivedData"
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/xcodebuild.log"

          xcodebuild \
            -project "$PROJECT_PATH" \
            -scheme "$PRODUCT_SCHEME" \
            -sdk iphonesimulator \
            -configuration Debug \
            -destination "id=$SIM_UDID" \
            -derivedDataPath "$DERIVED" \
            -resultBundlePath "$BUNDLE" \
            -skipMacroValidation \
            -skipPackagePluginValidation \
            ONLY_ACTIVE_ARCH=YES \
            "EXCLUDED_ARCHS[sdk=iphonesimulator*]=i386 x86_64" \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            -showBuildTimingSummary \
            build | tee "$LOG"

      - name: Stop early if no .app produced
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          APP_DIR="$(find "$CM_BUILD_DIR/DerivedData/Build/Products/Debug-iphonesimulator" -maxdepth 1 -type d -name '*.app' -print -quit || true)"
          if [[ -z "${APP_DIR:-}" ]]; then
            echo "❌ No .app produced. See build logs above."
            exit 1
          fi
          echo "export APP_DIR=\"$APP_DIR\"" >> "$CM_ENV"

      - name: Show .app contents summary
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV"
          echo "App path: $APP_DIR"
          echo "Size: $(du -sh "$APP_DIR" | cut -f1)"
          find "$APP_DIR" -maxdepth 2 -type f | head -n 50

      - name: Extract errors from .xcresult (grouped by file)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          [[ -d "$BUNDLE" ]] || BUNDLE="$CM_BUILD_DIR/build-diagnostic.xcresult"

          if [[ -e "$BUNDLE" ]]; then
            echo "=== Extracting Swift compiler errors from: $BUNDLE ==="
            # Pass bundle path as argv[1] to Python (don’t rely on env)
            python3 - "$BUNDLE" <<'PY'
import json, sys, subprocess, os
p = sys.argv[1] if len(sys.argv)>1 else ""
if not p or not os.path.exists(p):
    print("No xcresult bundle to parse")
    sys.exit(0)

try:
    out = subprocess.check_output(["xcrun","xcresulttool","get","object","--legacy","--format","json","--path",p])
    j = json.loads(out)
except Exception as e:
    print("xcresulttool failed:", e)
    sys.exit(0)

files = {}
def walk(x):
    if isinstance(x, dict):
        if x.get('issueType') == 'error':
            msg = x.get('message',{}).get('text','(no message)')
            loc = x.get('documentLocationInCreatingWorkspace',{})
            url = loc.get('url') or ""
            line = loc.get('line')
            files.setdefault(url, []).append((line, msg))
        for v in x.values():
            walk(v)
    elif isinstance(x, list):
        for v in x:
            walk(v)

walk(j)
if not files:
    print("No compiler errors found in xcresult.")
    sys.exit(0)

print("\n=== Compiler errors by file ===")
for url, errs in files.items():
    print(f"\nFILE: {url or '(unknown)'}")
    for ln, msg in sorted(errs, key=lambda t: (t[0] or 0, t[1])):
        where = f"line {ln}" if ln else "line ?"
        print(f"  • {where}: {msg}")
PY
          else
            echo "No result bundle found."
          fi

      - name: Package simulator app for Preview (validate first)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV"

          PLIST="$APP_DIR/Info.plist"
          [[ -f "$PLIST" ]] || { echo "❌ $APP_DIR has no Info.plist — invalid app."; exit 1; }

          EXEC=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleExecutable' "$PLIST" 2>/dev/null || true)
          [[ -n "${EXEC:-}" && -f "$APP_DIR/$EXEC" ]] || { echo "❌ Missing main executable — app wasn’t linked."; exit 1; }

          mkdir -p "$CM_ARTIFACTS"
          ZIP="$CM_ARTIFACTS/app-preview.zip"
          (
            cd "$(dirname "$APP_DIR")"
            /usr/bin/zip -qry "$ZIP" "$(basename "$APP_DIR")"
          )
          echo "✅ Preview artifact: $ZIP"
          echo "export CM_PREVIEW_IOS_ARTIFACT=$ZIP" >> "$CM_ENV"

      - name: Archive build artifacts
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV"
          mkdir -p artifacts Payload
          cp -R "$APP_DIR" artifacts/
          cp -R "$APP_DIR" Payload/
          (cd Payload && /usr/bin/zip -qry "$CM_ARTIFACTS/AgentDashboard.ipa" .)
          /usr/bin/zip -qry "$CM_ARTIFACTS/AgentDashboard.app.zip" "$APP_DIR"
          /usr/bin/zip -qry "$CM_ARTIFACTS/app-preview.zip" "$APP_DIR"
          echo "Artifacts in $CM_ARTIFACTS:"
          ls -lah "$CM_ARTIFACTS"

    artifacts:
      - $CM_ARTIFACTS/AgentDashboard.ipa
      - $CM_ARTIFACTS/AgentDashboard.app.zip
      - $CM_ARTIFACTS/app-preview.zip
