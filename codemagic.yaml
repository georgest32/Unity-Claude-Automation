workflows:
  ios-tca-dashboard:
    name: iOS TCA Dashboard
    max_build_duration: 60
    instance_type: mac_mini_m2

    environment:
      xcode: 16.4
      cocoapods: default
      vars:
        PROJECT_PATH: "iOS-App/AgentDashboard/AgentDashboard.xcodeproj"
        SCHEME: "AgentDashboard"

    scripts:
      - name: Toolchain info
        script: |
          #!/usr/bin/env bash
          set -e
          xcodebuild -version
          swift --version
          xcrun simctl list runtimes

      - name: Clean DerivedData & resolve packages (with logs)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          echo "=== Cleaning DerivedData and caches ==="
          rm -rf "$CM_BUILD_DIR/DerivedData" || true
          rm -rf "$HOME/Library/Developer/Xcode/DerivedData" 2>/dev/null || true
          rm -rf "$CM_BUILD_DIR/SourcePackages" 2>/dev/null || true
          
          echo "=== xcodebuild toolchain ==="
          xcodebuild -version
          swift --version || true
          
          echo "=== Resolve Swift packages ==="
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -clonedSourcePackagesDirPath "$CM_BUILD_DIR/SourcePackages" \
            -verbose || true
          
          echo "=== Show build settings (captures SPM locations) ==="
          xcodebuild -showBuildSettings \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" | tee "$CM_BUILD_DIR/build-settings.txt"
          
          echo "=== Find Package.resolved files ==="
          find iOS-App -name Package.resolved -print -exec cat {} \; || true

      - name: Select iOS 18.x simulator, set SIM_UDID for xcodebuild
        script: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Help TCA macro host compile
          export MACOSX_DEPLOYMENT_TARGET=14.0

          echo "=== Selecting iOS 18.x simulator ==="
          # Use self-contained external script
          SIM_UDID="$(python3 ci/select_simulator.py "18.5" "iPhone 16 Pro")"
          if [[ -z "${SIM_UDID:-}" ]]; then
            echo "ERROR: Could not find an iOS 18.x simulator UDID" >&2
            echo "== Devices =="; xcrun simctl list devices
            exit 1
          fi

          echo "Selected simulator UDID: $SIM_UDID"
          echo "export SIM_UDID=$SIM_UDID" >> "$CM_ENV"

      - name: Debug - list all @main App matches
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          echo "=== Finding all @main declarations ==="
          if command -v rg &> /dev/null; then
            echo "Using ripgrep:"
            rg -n -g 'iOS-App/**/*.swift' '@main' || echo "No matches found"
          else
            echo "Using grep:"
            grep -r -n "@main" iOS-App --include="*.swift" || echo "No matches found"
          fi
          echo ""
          echo "=== Checking which files are in Xcode project ==="
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          echo "AgentDashboardApp.swift in project: $(grep -c "AgentDashboardApp.swift" "$PROJ" || echo 0)"

      - name: Sanity - ensure single @main App (project files only)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          echo "=== Checking for @main App in project files ==="
          
          # Simple approach: just check if AgentDashboardApp.swift exists and has @main
          mainfile="iOS-App/AgentDashboard/AgentDashboard/AgentDashboardApp.swift"
          
          if [[ -f "$mainfile" ]]; then
            if grep -q "@main" "$mainfile"; then
              echo "✅ Found @main in AgentDashboardApp.swift"
            else
              echo "❌ AgentDashboardApp.swift missing @main"
              exit 1
            fi
          else
            echo "❌ AgentDashboardApp.swift not found"
            exit 1
          fi
          
          # Check for any other @main declarations
          otherMains=$(find iOS-App -name "*.swift" -not -name "AgentDashboardApp.swift" -exec grep -l "@main" {} \; | wc -l)
          
          if [ "$otherMains" -gt 0 ]; then
            echo "❌ Found @main in other files:"
            find iOS-App -name "*.swift" -not -name "AgentDashboardApp.swift" -exec grep -l "@main" {} \;
            exit 1
          fi
          
          echo "✅ Single @main App verified"

      - name: Sanity - verify key files are in Xcode project
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          echo "=== Checking target membership ==="
          
          # Critical files that MUST be in project
          critical=( ContentView.swift DashboardView.swift )
          for f in "${critical[@]}"; do
            if ! grep -q "$f" "$PROJ"; then
              echo "❌ CRITICAL: Not in project: $f"
              exit 1
            else
              echo "✅ Found: $f"
            fi
          done
          
          # Optional files (okay if missing due to temp wrappers)
          optional=( AgentsView.swift TerminalView.swift AnalyticsView.swift SettingsView.swift )
          for f in "${optional[@]}"; do
            if ! grep -q "$f" "$PROJ"; then
              echo "⚠️  Not in project: $f (using temp wrapper)"
            else
              echo "✅ Found: $f"
            fi
          done

      - name: Project integrity check
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PBX="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"

          echo "=== Sanity check pbxproj ==="
          head -n 10 "$PBX" || true
          echo

          # Check if it's a valid plist
          if ! plutil -lint "$PBX" 2>/dev/null; then
            echo "❌ project.pbxproj is not a valid plist. Restore it before building."
            exit 74
          fi

          echo "=== List targets (quick parse) ==="
          xcodebuild -list -project iOS-App/AgentDashboard/AgentDashboard.xcodeproj || true
          
          echo "✅ Project file is valid"

      - name: Prebuild Swift macros for host (macOS)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          export DEVELOPER_DIR="/Applications/Xcode-16.4.app"
          
          # DerivedData paths Codemagic is already using
          DD="$CM_BUILD_DIR/DerivedData"
          PKG="$DD/SourcePackages/checkouts"
          
          echo "=== Ensure packages are resolved ==="
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT_PATH" \
            -derivedDataPath "$DD"
          
          echo "=== Build macro targets for macOS host ==="
          # TCA
          if [ -d "$PKG/swift-composable-architecture" ]; then
            echo "Building ComposableArchitectureMacros..."
            swift build -c debug --package-path "$PKG/swift-composable-architecture" \
              --target ComposableArchitectureMacros || echo "Failed to build TCA macros"
          fi
          
          # CasePaths
          if [ -d "$PKG/swift-case-paths" ]; then
            echo "Building CasePathsMacros..."
            swift build -c debug --package-path "$PKG/swift-case-paths" \
              --target CasePathsMacros || echo "Failed to build CasePaths macros"
          fi
          
          # Dependencies
          if [ -d "$PKG/swift-dependencies" ]; then
            echo "Building DependenciesMacrosPlugin..."
            swift build -c debug --package-path "$PKG/swift-dependencies" \
              --target DependenciesMacrosPlugin || echo "Failed to build Dependencies macros"
          fi
          
          # Perception
          if [ -d "$PKG/swift-perception" ]; then
            echo "Building PerceptionMacros..."
            swift build -c debug --package-path "$PKG/swift-perception" \
              --target PerceptionMacros || echo "Failed to build Perception macros"
          fi
          
          echo "=== Host-built macro dylibs ==="
          find "$DD/Build/Products" -maxdepth 3 -type f \( -name "*.dylib" -o -name "*.bundle" \) -print || true
          find "$DD/Build/Products" -maxdepth 3 -type d -name "*Macros*" -print || true

      - name: Sanity - print APIClient.swift head & checksum
        script: |
          #!/usr/bin/env bash
          set -e
          F="iOS-App/AgentDashboard/AgentDashboard/Network/APIClient.swift"
          echo "=== APIClient.swift HEAD (first 120 lines) ==="
          sed -n '1,120p' "$F" || true
          echo ""
          echo "=== APIClient.swift sha256 ==="
          shasum -a 256 "$F" || true

      - name: Debug - commit & branch
        script: |
          #!/usr/bin/env bash
          echo "=== Git info ==="
          echo "CM_BRANCH=${CM_BRANCH:-unset}"
          echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Last 5 commits:"
          git log --oneline -5

      - name: Build for iOS Simulator (arm64, single device, with result bundle)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV" || true

          DERIVED="$CM_BUILD_DIR/DerivedData"
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/build.log"

          # Macro plugins run on the macOS host; set a modern host target
          export MACOSX_DEPLOYMENT_TARGET=14.0

          echo "=== Building Debug for simulator id=$SIM_UDID ==="
          
          # Capture build exit code but don't fail the step
          status=0
          xcodebuild \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -sdk iphonesimulator \
            -configuration Debug \
            -destination "platform=iOS Simulator,id=$SIM_UDID,arch=arm64" \
            -derivedDataPath "$DERIVED" \
            -resultBundlePath "$BUNDLE" \
            -skipMacroValidation \
            -skipPackagePluginValidation \
            ONLY_ACTIVE_ARCH=YES \
            EXCLUDED_ARCHS="i386 x86_64" \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            -showBuildTimingSummary \
            build | tee "$LOG" || status=$?
          
          echo "$status" > "$CM_BUILD_DIR/build_status.txt"
          echo "Build exited with status: $status"
          
          echo "=== Where did the macro bundles land? ==="
          echo "Host (Debug) macros:"
          find "$DERIVED/Build/Products/Debug" -type f \( -name "*.dylib" -o -name "*.bundle" \) 2>/dev/null || echo "No host macros found"
          echo ""
          echo "Simulator (Debug-iphonesimulator) macros:"
          find "$DERIVED/Build/Products/Debug-iphonesimulator" -type d -name "*Macros*" 2>/dev/null || echo "No simulator macros found"
          echo ""
          echo "All macro-related files:"
          find "$DERIVED/Build/Products" -maxdepth 3 -name "*Macros*" -print || true
          
          # Always succeed this step so diagnostics can run
          exit 0

      # ---------- Diagnostics: richer error reporting -----------
      - name: Extract ALL Swift diagnostics (file + line) v2
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/build.log"

          if [[ ! -d "$BUNDLE" ]]; then
            echo "No xcresult bundle at: $BUNDLE"
            exit 0
          fi

          # First try the diagnostics command which gives the best output
          echo "=== Extracting diagnostics from xcresult ==="
          xcrun xcresulttool diagnostics --path "$BUNDLE" 2>&1 || true
          
          echo ""
          echo "=== Extracting formatted results ==="
          xcrun xcresulttool formatDescription --path "$BUNDLE" 2>&1 || true
          
          # Xcode 16.4: legacy mode required for 'get'
          xcrun xcresulttool get --legacy --format json --path "$BUNDLE" > "$CM_BUILD_DIR/xc.json" || {
            echo "xcresulttool failed; printing basic info and falling back to raw log."
            ls -al "$BUNDLE" || true
          }

          echo "=== A) Issues from actionResult.issues.errorSummaries / warningSummaries ==="
          PY_A="$CM_BUILD_DIR/py_extract_a.py"
          printf '%s\n' \
            'import json, os, sys' \
            'p = os.path.join(os.environ.get("CM_BUILD_DIR","."), "xc.json")' \
            'try:' \
            '    with open(p, "r", encoding="utf-8") as f:' \
            '        root = json.load(f)' \
            'except Exception as e:' \
            '    print(f"(could not open {p}: {e})"); sys.exit(0)' \
            '' \
            'out=[]' \
            'def walk(node):' \
            '    if isinstance(node, dict):' \
            '        if node.get("_type", {}).get("_name") == "ActionRecord":' \
            '            issues = node.get("issues", {})' \
            '            for key in ("errorSummaries","warningSummaries"): ' \
            '                v = issues.get(key, {})' \
            '                vals = v.get("_values", []) if isinstance(v, dict) else []' \
            '                for it in vals:' \
            '                    msg = (it.get("message") or {}).get("text","")' \
            '                    loc = it.get("documentLocationInCreatingWorkspace") or {}' \
            '                    url = loc.get("url",""); line = loc.get("line")' \
            '                    out.append((key, msg, url, line))' \
            '        for val in node.values(): walk(val)' \
            '    elif isinstance(node, list):' \
            '        for val in node: walk(val)' \
            '' \
            'walk(root)' \
            'if out:' \
            '    print(f"Found {len(out)} summarized issues\n")' \
            '    for kind,msg,url,line in out[:50]:' \
            '        print(("✖" if kind=="errorSummaries" else "⚠"), msg)' \
            '        if url:  print("   file:", url)' \
            '        if line: print("   line:", line)' \
            '        print()' \
            'else:' \
            '    print("(no summarized issues in actionResult)")' \
            > "$PY_A"
          python3 "$PY_A"

          echo
          echo "=== B) Follow logRef(s) and print error lines ==="
          PY_B="$CM_BUILD_DIR/py_extract_b.py"
          printf '%s\n' \
            'import json, os, subprocess, sys' \
            'cm = os.environ.get("CM_BUILD_DIR",".")' \
            'bundle = os.path.join(cm, "build.xcresult")' \
            'xcjson = os.path.join(cm, "xc.json")' \
            'try:' \
            '    root = json.load(open(xcjson, "r", encoding="utf-8"))' \
            'except Exception as e:' \
            '    print(f"(no xc.json to parse: {e})"); sys.exit(0)' \
            '' \
            'ids=set()' \
            'def walk(n):' \
            '    if isinstance(n, dict):' \
            '        for k in ("logRef","consoleLogRef"):' \
            '            ref = n.get(k)' \
            '            if isinstance(ref, dict) and ref.get("_id"):' \
            '                ids.add(ref["_id"])' \
            '        for v in n.values(): walk(v)' \
            '    elif isinstance(n, list):' \
            '        for v in n: walk(v)' \
            'walk(root)' \
            '' \
            'def get_text(_id):' \
            '    try:' \
            '        out = subprocess.check_output([' \
            '            "xcrun","xcresulttool","get","--legacy","--format","json","--path", bundle, "--id", _id' \
            '        ], text=True)' \
            '    except subprocess.CalledProcessError:' \
            '        return ""' \
            '    try:' \
            '        j = json.loads(out)' \
            '    except Exception:' \
            '        return out' \
            '    acc=[]' \
            '    def collect(n):' \
            '        if isinstance(n, dict):' \
            '            t = n.get("text")' \
            '            if isinstance(t, str): acc.append(t)' \
            '            for v in n.values(): collect(v)' \
            '        elif isinstance(n, list):' \
            '            for v in n: collect(v)' \
            '    collect(j)' \
            '    return "".join(acc)' \
            '' \
            'hit=False' \
            'for _id in ids:' \
            '    txt = get_text(_id)' \
            '    if not txt: continue' \
            '    lines = [l for l in txt.splitlines() if " error:" in l or l.strip().startswith("error:")]' \
            '    if lines:' \
            '        hit=True' \
            '        print(f"--- LOG ID {_id} (filtered) ---")' \
            '        print("\n".join(lines[:200]))' \
            '        print()' \
            'if not hit:' \
            '    print("(no error-like lines found in logRef text)")' \
            > "$PY_B"
          python3 "$PY_B"

          echo
          echo "=== C) Fallback: tail build log ==="
          if [[ -f "$LOG" ]]; then
            tail -n 500 "$LOG" | sed -n '/error:/,$p' | head -n 400 || true
          else
            echo "(no $LOG)"
          fi

          # Never fail this step so the final status gate can re-emit the build code
          exit 0


      - name: Show failing source context (best effort)
        script: |
          #!/usr/bin/env bash
          set +e
          python3 ci/show_source_context.py
          true
          
      - name: Detect dependency graph issues
        script: |
          #!/usr/bin/env bash
          set +e
          python3 ci/detect_dependency_errors.py "$CM_BUILD_DIR/build.log"
          true

      - name: Publish diagnostics & build settings
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          DERIVED="$CM_BUILD_DIR/DerivedData"
          mkdir -p "$CM_EXPORT_DIR"
          [[ -f "$CM_BUILD_DIR/build.log" ]] && cp "$CM_BUILD_DIR/build.log" "$CM_EXPORT_DIR/"
          [[ -f "$CM_BUILD_DIR/xc.json"   ]] && cp "$CM_BUILD_DIR/xc.json" "$CM_EXPORT_DIR/xcresult.json"
          [[ -d "$CM_BUILD_DIR/build.xcresult" ]] && cp -R "$CM_BUILD_DIR/build.xcresult" "$CM_EXPORT_DIR/"
          if [[ -d "$DERIVED" ]]; then
            (cd "$DERIVED" && zip -qry "$CM_EXPORT_DIR/deriveddata-logs.zip" Logs Build/Intermediates.noindex || true)
            xcodebuild -project "$PROJECT_PATH" -scheme "$SCHEME" -showBuildSettings > "$CM_EXPORT_DIR/build-settings.txt" || true
          fi
          echo "Artifacts:"
          ls -lah "$CM_EXPORT_DIR"

      - name: Fail pipeline if build failed
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          status=$(cat "$CM_BUILD_DIR/build_status.txt" 2>/dev/null || echo 0)
          if [[ "$status" -ne 0 ]]; then
            echo "❌ xcodebuild exited with status $status"
            exit "$status"
          fi
          echo "✅ Build succeeded"

      # ---------- Package a Preview artifact, only if the .app is real ----------
      - name: Validate and package app for Codemagic Preview (conditional)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          DERIVED="$CM_BUILD_DIR/DerivedData/Build/Products/Debug-iphonesimulator"
          APP_DIR="$(find "$DERIVED" -maxdepth 1 -type d -name '*.app' -print -quit || true)"

          if [[ -z "${APP_DIR:-}" ]]; then
            echo "❌ No .app produced (build failed). Skipping preview packaging."
            exit 0
          fi

          PLIST="$APP_DIR/Info.plist"
          if [[ ! -f "$PLIST" ]]; then
            echo "❌ $APP_DIR has no Info.plist — invalid app. Skipping."
            exit 0
          fi

          EXEC=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleExecutable' "$PLIST" 2>/dev/null || true)
          if [[ -z "${EXEC:-}" || ! -f "$APP_DIR/$EXEC" ]]; then
            echo "❌ Missing main executable — app wasn’t linked. Skipping."
            exit 0
          fi

          mkdir -p "$CM_EXPORT_DIR"
          ZIP="$CM_EXPORT_DIR/app-preview.zip"
          ( cd "$(dirname "$APP_DIR")" && /usr/bin/zip -qry "$ZIP" "$(basename "$APP_DIR")" )
          cp -R "$APP_DIR" "$CM_EXPORT_DIR/"

          echo "✅ Preview artifact: $ZIP"
          du -sh "$APP_DIR" || true
          ls -lah "$CM_EXPORT_DIR"

    artifacts:
      - $CM_ARTIFACTS/**