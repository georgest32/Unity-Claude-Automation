workflows:
  ios-tca-dashboard:
    name: iOS TCA Dashboard
    max_build_duration: 60
    instance_type: mac_mini_m2

    environment:
      xcode: 16.4
      cocoapods: default
      vars:
        PROJECT_PATH: "iOS-App/AgentDashboard/AgentDashboard.xcodeproj"
        SCHEME: "AgentDashboard"

    scripts:
      - name: Toolchain info
        script: |
          #!/usr/bin/env bash
          set -e
          xcodebuild -version
          swift --version
          xcrun simctl list runtimes

      - name: Clean DerivedData & resolve packages (with logs)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          echo "=== Cleaning DerivedData ==="
          rm -rf "$CM_BUILD_DIR/DerivedData" || true
          
          echo "=== xcodebuild toolchain ==="
          xcodebuild -version
          swift --version || true
          
          echo "=== Resolve Swift packages ==="
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -clonedSourcePackagesDirPath "$CM_BUILD_DIR/SourcePackages" \
            -verbose || true
          
          echo "=== Show build settings (captures SPM locations) ==="
          xcodebuild -showBuildSettings \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" | tee "$CM_BUILD_DIR/build-settings.txt"
          
          echo "=== Find Package.resolved files ==="
          find iOS-App -name Package.resolved -print -exec cat {} \; || true

      - name: Select iOS 18.x simulator, set SIM_UDID for xcodebuild
        script: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Help TCA macro host compile
          export MACOSX_DEPLOYMENT_TARGET=13.0

          echo "=== Selecting iOS 18.x simulator ==="
          # Use self-contained external script
          SIM_UDID="$(python3 ci/select_simulator.py "18.5" "iPhone 16 Pro")"
          if [[ -z "${SIM_UDID:-}" ]]; then
            echo "ERROR: Could not find an iOS 18.x simulator UDID" >&2
            echo "== Devices =="; xcrun simctl list devices
            exit 1
          fi

          echo "Selected simulator UDID: $SIM_UDID"
          echo "export SIM_UDID=$SIM_UDID" >> "$CM_ENV"

      - name: Debug - list all @main App matches
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          echo "=== Finding all @main declarations ==="
          if command -v rg &> /dev/null; then
            echo "Using ripgrep:"
            rg -n -g 'iOS-App/**/*.swift' '@main' || echo "No matches found"
          else
            echo "Using grep:"
            grep -r -n "@main" iOS-App --include="*.swift" || echo "No matches found"
          fi
          echo ""
          echo "=== Checking which files are in Xcode project ==="
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          echo "AgentDashboardApp.swift in project: $(grep -c "AgentDashboardApp.swift" "$PROJ" || echo 0)"

      - name: Sanity - ensure single @main App (project files only)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          echo "=== Checking for @main App in project files ==="
          
          # Simple approach: just check if AgentDashboardApp.swift exists and has @main
          mainfile="iOS-App/AgentDashboard/AgentDashboard/AgentDashboardApp.swift"
          
          if [[ -f "$mainfile" ]]; then
            if grep -q "@main" "$mainfile"; then
              echo "✅ Found @main in AgentDashboardApp.swift"
            else
              echo "❌ AgentDashboardApp.swift missing @main"
              exit 1
            fi
          else
            echo "❌ AgentDashboardApp.swift not found"
            exit 1
          fi
          
          # Check for any other @main declarations
          otherMains=$(find iOS-App -name "*.swift" -not -name "AgentDashboardApp.swift" -exec grep -l "@main" {} \; | wc -l)
          
          if [ "$otherMains" -gt 0 ]; then
            echo "❌ Found @main in other files:"
            find iOS-App -name "*.swift" -not -name "AgentDashboardApp.swift" -exec grep -l "@main" {} \;
            exit 1
          fi
          
          echo "✅ Single @main App verified"

      - name: Sanity - verify key files are in Xcode project
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PROJ="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"
          
          echo "=== Checking target membership ==="
          
          # Critical files that MUST be in project
          critical=( ContentView.swift DashboardView.swift )
          for f in "${critical[@]}"; do
            if ! grep -q "$f" "$PROJ"; then
              echo "❌ CRITICAL: Not in project: $f"
              exit 1
            else
              echo "✅ Found: $f"
            fi
          done
          
          # Optional files (okay if missing due to temp wrappers)
          optional=( AgentsView.swift TerminalView.swift AnalyticsView.swift SettingsView.swift )
          for f in "${optional[@]}"; do
            if ! grep -q "$f" "$PROJ"; then
              echo "⚠️  Not in project: $f (using temp wrapper)"
            else
              echo "✅ Found: $f"
            fi
          done

      - name: Project integrity check
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          PBX="iOS-App/AgentDashboard/AgentDashboard.xcodeproj/project.pbxproj"

          echo "=== Sanity check pbxproj ==="
          head -n 10 "$PBX" || true
          echo

          # Check if it's a valid plist
          if ! plutil -lint "$PBX" 2>/dev/null; then
            echo "❌ project.pbxproj is not a valid plist. Restore it before building."
            exit 74
          fi

          echo "=== List targets (quick parse) ==="
          xcodebuild -list -project iOS-App/AgentDashboard/AgentDashboard.xcodeproj || true
          
          echo "✅ Project file is valid"

      - name: Build for iOS Simulator (arm64, single device, with result bundle)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          source "$CM_ENV" || true

          DERIVED="$CM_BUILD_DIR/DerivedData"
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          LOG="$CM_BUILD_DIR/xcodebuild.log"

          # Macro plugins run on the macOS host; set a modern host target
          export MACOSX_DEPLOYMENT_TARGET=13.0

          echo "=== Building Debug for simulator id=$SIM_UDID ==="
          
          # Capture build exit code but don't fail the step
          status=0
          xcodebuild \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -sdk iphonesimulator \
            -configuration Debug \
            -destination "platform=iOS Simulator,id=$SIM_UDID,arch=arm64" \
            -derivedDataPath "$DERIVED" \
            -resultBundlePath "$BUNDLE" \
            ONLY_ACTIVE_ARCH=YES \
            EXCLUDED_ARCHS="i386 x86_64" \
            SWIFT_MACRO_PLUGIN_ENABLE=YES \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            -showBuildTimingSummary \
            -skipPackagePluginValidation \
            -skipMacroValidation \
            build | tee "$LOG" || status=$?
          
          echo "$status" > "$CM_BUILD_DIR/build_status.txt"
          echo "Build exited with status: $status"
          
          # Always succeed this step so diagnostics can run
          exit 0

      # ---------- Diagnostics: richer error reporting -----------
      - name: Extract ALL Swift diagnostics (file + line) v2
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          BUNDLE="$CM_BUILD_DIR/build.xcresult"
          RAWLOG="$CM_BUILD_DIR/build.log"

          if [[ ! -d "$BUNDLE" ]]; then
            echo "No xcresult bundle at: $BUNDLE"
            exit 0
          fi

          xcrun xcresulttool get --format json --path "$BUNDLE" > "$CM_BUILD_DIR/xc.json"

          echo "=== A) Issues from actionResult.issues.errorSummaries / warningSummaries ==="
          python3 - <<'PY'
import json, sys, os
p = os.path.join(os.environ.get("CM_BUILD_DIR","."), "xc.json")
with open(p, "r", encoding="utf-8") as f:
    root = json.load(f)

def deref(obj):
    """xcresulttool stores lots of references; this yields dicts uniformly."""
    if isinstance(obj, dict) and 'type' in obj and obj.get('_id'):
        return obj  # already an object
    return obj

def walk_issues(node, out):
    if isinstance(node, dict):
        if node.get('_type', {}).get('_name') == 'ActionRecord':
            issues = node.get('issues', {})
            for k in ('errorSummaries', 'warningSummaries'):
                arr = issues.get(k, {}).get('_values', []) if isinstance(issues.get(k), dict) else []
                for it in arr:
                    text = it.get('message', {}).get('text', '')
                    doc = it.get('documentLocationInCreatingWorkspace', {}) or {}
                    url = doc.get('url', '')
                    line = doc.get('line')
                    out.append((k[:-9], text, url, line))
        for v in node.values():
            walk_issues(v, out)
    elif isinstance(node, list):
        for v in node:
            walk_issues(v, out)

out=[]
walk_issues(root, out)
if out:
    print(f"Found {len(out)} summarized issues\n")
    for i,(kind,msg,url,line) in enumerate(out[:50],1):
        print(f"{'✖' if kind=='error' else '⚠'} {msg}")
        if url:  print(f"   file: {url}")
        if line: print(f"   line: {line}")
        print()
else:
    print("(no summarized issues in actionResult)")
PY

          echo
          echo "=== B) Follow logRef(s) and print error lines ==="
          # Gather all logRef IDs then fetch & grep them
          python3 - <<'PY'
import json, sys, os, subprocess, tempfile, re

bundle = os.environ["CM_BUILD_DIR"] + "/build.xcresult"
with open(os.environ["CM_BUILD_DIR"] + "/xc.json","r",encoding="utf-8") as f:
    root = json.load(f)

ids=set()
def walk(node):
    if isinstance(node, dict):
        # ActionRecord.logRef or ActionResult.logRef or BuildOperationDiagnostics
        logref = node.get('logRef') or node.get('consoleLogRef') or {}
        if isinstance(logref, dict):
            _id = logref.get('_id')
            if _id: ids.add(_id)
        for v in node.values():
            walk(v)
    elif isinstance(node, list):
        for v in node: walk(v)
walk(root)

if not ids:
    print("(no logRef ids found)")
    sys.exit(0)

def get_id_text(_id):
    try:
        out = subprocess.check_output(["xcrun","xcresulttool","get","--format","json","--path", bundle, "--id", _id], text=True)
    except subprocess.CalledProcessError:
        return None
    try:
        j = json.loads(out)
        # Logs can be nested. Most text sits under 'text' keys in fragments.
        def collect(n, acc):
            if isinstance(n, dict):
                if 'text' in n and isinstance(n['text'], str):
                    acc.append(n['text'])
                for v in n.values(): collect(v, acc)
            elif isinstance(n, list):
                for v in n: collect(v, acc)
        acc=[]
        collect(j, acc)
        return "".join(acc)
    except Exception:
        return out

hit_any=False
for _id in ids:
    txt = get_id_text(_id)
    if not txt: continue
    # Print only the interesting lines (Swift compile errors)
    lines = [l for l in txt.splitlines() if "error:" in l or " Swift" in l or "compile" in l.lower()]
    if lines:
        hit_any=True
        print(f"--- LOG ID {_id} (filtered) ---")
        print("\n".join(lines[:200]))
        print()
if not hit_any:
    print("(no error-like lines found in logRef text)")
PY

          echo
          echo "=== C) Fallback: tail raw xcodebuild log ==="
          if [[ -f "$RAWLOG" ]]; then
            echo "--- tail -n 500 $RAWLOG ---"
            tail -n 500 "$RAWLOG" | sed -n '/error:/,$p' | head -n 400 || true
          else
            echo "(no $RAWLOG available)"
          fi

          echo
          echo "========================================="

      - name: Show failing source context (best effort)
        script: |
          #!/usr/bin/env bash
          set +e
          python3 ci/show_source_context.py
          true
          
      - name: Detect dependency graph issues
        script: |
          #!/usr/bin/env bash
          set +e
          python3 ci/detect_dependency_errors.py "$CM_BUILD_DIR/xcodebuild.log"
          true

      - name: Publish diagnostics & build settings
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          DERIVED="$CM_BUILD_DIR/DerivedData"
          mkdir -p "$CM_ARTIFACTS"
          [[ -f "$CM_BUILD_DIR/xcodebuild.log" ]] && cp "$CM_BUILD_DIR/xcodebuild.log" "$CM_ARTIFACTS/"
          [[ -f "$CM_BUILD_DIR/xcresult.json"   ]] && cp "$CM_BUILD_DIR/xcresult.json"   "$CM_ARTIFACTS/"
          if [[ -d "$DERIVED" ]]; then
            (cd "$DERIVED" && zip -qry "$CM_ARTIFACTS/deriveddata-logs.zip" Logs Build/Intermediates.noindex || true)
            xcodebuild -project "$PROJECT_PATH" -scheme "$SCHEME" -showBuildSettings > "$CM_ARTIFACTS/build-settings.txt" || true
          fi
          echo "Artifacts:"
          ls -lah "$CM_ARTIFACTS"

      - name: Fail pipeline if build failed
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          status=$(cat "$CM_BUILD_DIR/build_status.txt" 2>/dev/null || echo 0)
          if [[ "$status" -ne 0 ]]; then
            echo "❌ xcodebuild exited with status $status"
            exit "$status"
          fi
          echo "✅ Build succeeded"

      # ---------- Package a Preview artifact, only if the .app is real ----------
      - name: Validate and package app for Codemagic Preview (conditional)
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          DERIVED="$CM_BUILD_DIR/DerivedData/Build/Products/Debug-iphonesimulator"
          APP_DIR="$(find "$DERIVED" -maxdepth 1 -type d -name '*.app' -print -quit || true)"

          if [[ -z "${APP_DIR:-}" ]]; then
            echo "❌ No .app produced (build failed). Skipping preview packaging."
            exit 0
          fi

          PLIST="$APP_DIR/Info.plist"
          if [[ ! -f "$PLIST" ]]; then
            echo "❌ $APP_DIR has no Info.plist — invalid app. Skipping."
            exit 0
          fi

          EXEC=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleExecutable' "$PLIST" 2>/dev/null || true)
          if [[ -z "${EXEC:-}" || ! -f "$APP_DIR/$EXEC" ]]; then
            echo "❌ Missing main executable — app wasn’t linked. Skipping."
            exit 0
          fi

          mkdir -p "$CM_ARTIFACTS"
          ZIP="$CM_ARTIFACTS/app-preview.zip"
          ( cd "$(dirname "$APP_DIR")" && /usr/bin/zip -qry "$ZIP" "$(basename "$APP_DIR")" )
          cp -R "$APP_DIR" "$CM_ARTIFACTS/"

          echo "✅ Preview artifact: $ZIP"
          du -sh "$APP_DIR" || true
          ls -lah "$CM_ARTIFACTS"

    artifacts:
      - $CM_ARTIFACTS/**